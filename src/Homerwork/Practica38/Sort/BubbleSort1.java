package Homerwork.Practica38.Sort;
//Алгоритм сравнивает соседние элементы и "всплывает" наибольшие значения в конец массива.
//Это напоминает пузырь, который всплывает вверх — отсюда и название "пузырьковая сортировка".
public class BubbleSort1 implements Sorting {//**главный метод программы**, с которого начинается выполнение Java-программы.
    public static void main(String[] args) {//`String[] args` — позволяет передавать аргументы из командной строки
        // (в этом примере они не используются).
        int[] arr = {64, 34, 25, 12, 22, 11, 90};//Объявляется массив целых чисел arr, который мы будем сортировать.
        BubbleSort1 bubbleSort1 = new BubbleSort1();
        //Создаётся объект `sort` класса `BubbleSort`.
        //Это позволяет использовать методы этого класса (в частности — `babbleSort(...)`).
        //Этот метод должен быть реализован в этом же классе (или унаследован от интерфейса Sorting).
        bubbleSort1.sort(arr);//После вызова arr будет отсортирован по возрастанию.

        //Печатаем заголовок, чтобы показать, что дальше будет выведен отсортированный массив.
        System.out.println("Sorted array: ");
        //Цикл вывода элементов массива
        for (int i = 0; i < arr.length; i++) {
            System.out.println(arr[i] + " ");
        }
    }

    @Override
    //sort(int[] arr) — метод называется sort и принимает на вход массив целых чисел (arr).
    public void sort(int[] arr) {
        int n = arr.length;
        //Получаем длину массива arr и сохраняем её в переменную n.
        //Это нужно, чтобы знать, сколько раз пройтись по массиву.
        boolean swapped;
        //Это нужно для оптимизации алгоритма — если за проход не произошло
        //ни одной перестановки, значит, массив уже отсортирован, и можно остановиться раньше.

        //Внешний цикл.Цикл i управляет количеством проходов по массиву.
        //После n - 1 прохода все элементы точно на месте.
        for (int i = 0; i < n - 1; i++) {
            swapped = false;
            //Считаем, что пока ни одной перестановки не произошло.

            //Bнутренний цикл.Мы сравниваем элементы от начала массива до n - i - 1, потому что:
            //В конце массива уже находятся отсортированные элементы (всплыли ранее).
            for (int j = 0; j < n - i - 1; j++) {

                //Если текущий элемент arr[j] больше, чем следующий arr[j + 1], значит,
                // они не в правильном порядке, и нужно их поменять местами.
                if (arr[j] > arr[j + 1]) {
                    //Перестановка элементов
                    int temp = arr[j];//Классическая перестановка (swap) через временную переменную temp.
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                    swapped = true;//После перестановки устанавливаем swapped = true, то есть на этом проходе были изменения.

                    //Проверка: были ли перестановки?
                    //После завершения одного внешнего прохода проверяем: были ли перестановки?
                    if (!swapped)
                        break;
                    //Если swapped == false, значит, все элементы уже в порядке, и можно прервать цикл досрочно,
                    //не делая лишние проходы.

                }

            }

        }

    }

}
