package Homerwork.Practica38.SortMerge;
//Общая идея сортировки слиянием (Merge Sort)
//Алгоритм основан на принципе "разделяй и властвуй":
//
//Разделение: Массив делится пополам рекурсивно, пока не останутся отдельные элементы.
//
//Слияние: Затем мелкие массивы сливаются обратно в отсортированном порядке.
import Homerwork.Practica38.Sort.Sorting;

public class MergeSort implements Sorting {
    // Объединение двух подмассивов arr[]
    // Первый подмассив - arr[l..m]
    // Второй подмассив - arr[m+1..r]
    // Этот метод сливает два отсортированных подмассива в один.
    //arr[] — исходный массив.
    //l — левый индекс.
    //m — середина.
    //r — правый индекс.


    //Слияние двух отсортированных частей
    public static void merge(int arr[], int l, int m, int r) {
        //Шаги внутри merge(...)
        int n1 = m - l + 1;
        int n2 = r - m;

        //Вычисляются размеры двух подмассивов:

        int L[] = new int[n1];//n1 - Размер левой части (кол-во элементов в L[])
        int R[] = new int[n2];//n2 - Размер правой частм (кол-во элементов в R[])

        //Создаются временные массивы для хранения копий подмассивов.
        //Заполняем временные массивы L[] и R[] элементами из исходного массива arr.
        //Если бы мы сразу начали перезаписывать arr[], то могли бы стереть элементы, которые ещё не успели сравнить.
        //Поэтому создаются копии обеих половинок — L[] и R[].
        for (int i = 0; i < n1; ++i) //Копирует элементы из первой половины массива arr[] в новый массив L[].
            L[i] = arr[l + i];
        for (int j = 0; j < n2; ++j) //Копирует элементы правой части массива arr[] в новый временный массив R[].
            R[j] = arr[m + 1 + j];
        //Затем мы сливаем их обратно в arr[] по одному элементу, сохраняя порядок.

        // Начальные индексы первого и второго подмассива
        int i = 0, j = 0;

        // Начальный индекс объединенного подмассива
        // Сравниваем элементы из L[] и R[].
        //Кладём наименьший в arr[k].
        int k = l;
        while (i < n1 && j < n2) {
            if (L[i] <= R[j]) {
                arr[k] = L[i];
                i++;
            }
            k++;
        }

        while (i < n1) {
            arr[k] = R[j];
            j++;
            k++;
        }

        //Добавляем оставшиеся элементы из L[] или R[], если какие-то остались (вдруг один массив уже закончился,
        // а другой — нет).

    }

    @Override
    public void sort(int[] arr) {

    }
}
