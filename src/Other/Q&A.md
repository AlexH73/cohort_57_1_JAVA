**Какой из следующих интерфейсов наиболее подходящий для представления упорядоченного списка объектов?**

- A) List
- B) Set
- C) Map
- D) Queue

Правильный ответ — **A) List**.

**List** — это интерфейс, который представляет собой упорядоченный список объектов, где элементы могут быть доступны по индексу, и порядок их добавления сохраняется. Это делает его наилучшим выбором для представления упорядоченного списка объектов.

- **Set** не гарантирует порядок элементов.
    
- **Map** представляет коллекцию пар "ключ-значение", а не просто список объектов.
    
- **Queue** представляет очередь, где элементы обрабатываются в порядке FIFO (First-In-First-Out), что тоже не подходит для упорядоченного списка.

---
````
Feedback

List представляет упорядоченную коллекцию, где элементы могут дублироваться.
````
___


**В какой коллекции порядок элементов гарантированно сохраняется?**

- A) HashSet
- B) LinkedHashSet
- C) TreeSet
- D) HashMap

Правильный ответ — **B) LinkedHashSet**.

**LinkedHashSet** — это коллекция, которая гарантированно сохраняет порядок элементов, в котором они были добавлены. В отличие от **HashSet**, который не сохраняет порядок, и **TreeSet**, который упорядочивает элементы по их естественному порядку или по заданному компаратору, **LinkedHashSet** сохраняет порядок вставки.

- **HashSet** не сохраняет порядок элементов.
    
- **TreeSet** упорядочивает элементы в естественном порядке или с использованием компаратора.
    
- **HashMap** сохраняет порядок по ключам, но сам по себе порядок значений не гарантируется.


Таким образом, **LinkedHashSet** — это коллекция, где порядок элементов сохраняется.

___
````
Feedback

В LinkedHashSet порядок элементов сохраняется в порядке их вставки.
````
___


**Какая коллекция автоматически сортирует элементы?**

- A) HashSet
- B) LinkedHashSet
- C) TreeSet
- D) LinkedList

Правильный ответ — **C) TreeSet**.

**TreeSet** автоматически сортирует элементы. Он реализует интерфейс **Set** и использует дерево для хранения элементов, что позволяет автоматически поддерживать их в отсортированном порядке, используя их естественный порядок или заданный компаратор.

- **HashSet** не сортирует элементы.
    
- **LinkedHashSet** сохраняет порядок добавления элементов, но не сортирует их.
    
- **LinkedList** сохраняет элементы в порядке их добавления, но не сортирует их автоматически.


Таким образом, **TreeSet** — это коллекция, которая автоматически сортирует элементы.
___
````
Feedback

TreeSet автоматически сортирует элементы по естественному порядку или с использованием компаратора.
````
___



***В каком из классов допускаются ключи с null?***

- A) TreeMap
- B) HashMap
- C) LinkedHashMap
- D) HashSet

Правильный ответ — **B) HashMap**.

**HashMap** допускает ключи с **null**. Вы можете использовать **null** в качестве ключа в **HashMap** (максимум один ключ с **null**), и он будет работать корректно. Это не так для **TreeMap**, где ключи должны быть сравнимыми, и **null** не поддерживается, потому что компаратор или естественный порядок не могут быть применены к **null**.

- **TreeMap** не поддерживает ключи с **null**.
- **LinkedHashMap** поддерживает ключи с **null**, как и **HashMap**.
- **HashSet** также поддерживает **null** в качестве элемента, поскольку он основан на **HashMap**.

Таким образом, **HashMap** — это класс, где допускаются ключи с **null**.

___



**Какая структура представляет последовательность элементов в порядке "первым пришел, первым ушел" (FIFO)?**

- A) Stack
- B) Queue
- C) List
- D) Set

Правильный ответ — **Queue**.

**Queue** (очередь) представляет структуру данных, которая работает по принципу "первым пришел, первым ушел" (FIFO, First-In-First-Out). Это означает, что элементы, добавленные в очередь первыми, будут удаляться первыми.

- **Queue** — это интерфейс, реализующий структуру данных для обработки элементов в порядке их добавления (FIFO).
- Другие структуры данных, такие как **Stack** (стек), работают по принципу LIFO (Last-In-First-Out), где последний элемент, добавленный в структуру, удаляется первым.

___
```
Feedback
Очередь (Queue) представляет структуру данных в порядке FIFO.
```
___




**Какой класс представляет структуру данных "последний пришел, первым ушел" (LIFO)?**

- A) Stack
- B) Queue
- C) ArrayList
- D) TreeSet

Правильный ответ — **Stack**.

**Stack** (стек) представляет структуру данных, которая работает по принципу "последний пришел, первым ушел" (LIFO, Last-In-First-Out). Это означает, что последний элемент, добавленный в стек, будет удалён первым.

- **Stack** — класс, реализующий структуру данных стек, где элементы добавляются и удаляются с одного конца, называемого вершиной стека.

Стеки используются в различных задачах, таких как управление вызовами функций, обработка обратных польских записей и многие другие.

---
```
Feedback
Stack представляет структуру данных в порядке LIFO.
```
---



**Какой из классов реализует двусвязный список?**

- A) ArrayList
- B) LinkedList
- C) HashSet
- D) TreeSet

Правильный ответ — **LinkedList**.

**LinkedList** реализует двусвязный список. В двусвязном списке каждый элемент (узел) содержит ссылку как на следующий, так и на предыдущий элемент, что позволяет эффективно перемещаться в обоих направлениях.

- **LinkedList** — это класс, который реализует интерфейсы **List** и **Deque**, и представляет собой двусвязный список.
- Другие структуры данных, такие как **ArrayList**, основаны на массиве и не являются двусвязными списками.

Таким образом, **LinkedList** — это класс, который реализует двусвязный список.

---




**Что характерно для Set?**

- A) Сохраняет порядок элементов
- B) Позволяет дублирование элементов
- C) Не допускает дублирование элементов
- D) Использует ключ-значение

Правильный ответ — **C) Не допускает дублирование элементов**.

**Set** — это коллекция, которая **не допускает дублирование элементов**. В отличие от **List**, где могут быть повторяющиеся элементы, в **Set** каждый элемент уникален. Однако порядок элементов в **Set** не гарантируется, если только это не специфическая реализация, такая как **LinkedHashSet**, которая сохраняет порядок добавления.

- **A) Сохраняет порядок элементов** — не всегда, это зависит от реализации (например, **HashSet** не сохраняет порядок, а **LinkedHashSet** сохраняет).
- **B) Позволяет дублирование элементов** — это неверно для **Set**, так как **Set** не допускает дублирования.
- **D) Использует ключ-значение** — это свойственно структурам данных, таким как **Map**, а не **Set**.

Таким образом, **Set** — это коллекция, которая не допускает дублирования элементов.

---



**Какой интерфейс использует пары "ключ-значение"?**

- A) List
- B) Set
- C) Map
- D) Queue

Правильный ответ — **C) Map**.

**Map** — это интерфейс, который представляет коллекцию пар "ключ-значение". В **Map** каждый ключ связан с одним значением, и каждый ключ в коллекции уникален. Это позволяет эффективно искать значения по ключу.

- **List** — представляет коллекцию элементов, где порядок элементов важен, но не поддерживает пару "ключ-значение".
- **Set** — представляет коллекцию уникальных элементов, но не использует пару "ключ-значение".
- **Queue** — представляет очередь, где элементы обрабатываются в порядке FIFO, и также не использует пару "ключ-значение".

Таким образом, для пар "ключ-значение" используется интерфейс **Map**.

---



**Какой из классов обеспечивает постоянное время выполнения для основных операций, таких как add, remove и contains?**

- A) TreeSet
- B) HashSet
- C) LinkedList
- D) TreeMap

Правильный ответ — **B) HashSet**.

**HashSet** обеспечивает постоянное время выполнения (O(1)) для основных операций, таких как **add**, **remove** и **contains** в среднем случае. Это связано с тем, что **HashSet** использует хеш-таблицу для хранения элементов, что позволяет быстро находить элементы, добавлять их и удалять.

- **TreeSet** имеет логарифмическое время выполнения для основных операций (O(log n)), так как элементы хранятся в отсортированном порядке.
- **LinkedList** имеет линейное время выполнения (O(n)) для операций **add**, **remove** и **contains** в худшем случае, так как элементы должны быть пройдены по списку.
- **TreeMap** также имеет логарифмическое время выполнения для основных операций (O(log n)).

Таким образом, **HashSet** обеспечивает постоянное время выполнения для основных операций в среднем случае.

---
```
Feedback
HashSet обычно предоставляет постоянное время выполнения для основных операций за счет использования хеш-таблицы.
```
---



**Вам необходимо реализовать коллекцию, в которой вы будете часто проверять наличие элемента. Какую структуру вы выберете?**

- A) HashSet
- B) ArrayList
- C) LinkedList
- D) Stack

Правильный ответ — **A) HashSet**.

Если вам нужно часто проверять наличие элемента в коллекции, то **HashSet** будет наилучшим выбором. **HashSet** использует хеш-таблицу для хранения элементов, что позволяет проверять наличие элемента за время **O(1)** в среднем случае.

- **ArrayList** — поиск элемента в **ArrayList** выполняется за время **O(n)**, так как для этого требуется пройти весь список.
- **LinkedList** — аналогично **ArrayList**, поиск элемента в **LinkedList** также выполняется за время **O(n)**.
- **Stack** — это структура данных, реализующая принцип LIFO (Last-In-First-Out), и поиск элемента также требует линейного времени **O(n)**.

Таким образом, **HashSet** обеспечит наиболее эффективную проверку наличия элемента.

---
```
Feedback
HashSet предоставляет постоянное время выполнения для операции contains, благодаря использованию хеш-таблицы.
```
___




**Вам нужно сохранить пары ключ-значение, где порядок добавления элементов важен. Какую структуру данных вы выберете?**

- A) HashMap
- B) LinkedHashMap
- C) HashSet
- D) TreeMap

Правильный ответ — **B) LinkedHashMap**.

**LinkedHashMap** сохраняет пары "ключ-значение", при этом порядок добавления элементов сохраняется. Это позволяет вам как хранить элементы в коллекции в виде пар ключ-значение, так и гарантировать, что элементы будут в том же порядке, в котором они были добавлены.

- **HashMap** не сохраняет порядок добавления элементов.
- **HashSet** — это коллекция, которая хранит только уникальные элементы, без пар ключ-значение.
- **TreeMap** упорядочивает элементы по ключу, а не по порядку добавления.

Таким образом, если вам нужно сохранить пары ключ-значение с сохранением порядка добавления, выбирайте **LinkedHashMap**.

---
```
Feedback
LinkedHashMap сохраняет порядок вставки элементов.
```
___



**Вам нужен список, в котором вы будете часто вставлять и удалять элементы из середины. Что вы выберете?**

- A) ArrayList
- B) LinkedList
- C) HashSet
- D) Stack

Правильный ответ — **B) LinkedList**.

**LinkedList** — это структура данных, которая оптимизирована для частых вставок и удалений элементов в середине списка. В **LinkedList** добавление и удаление элементов выполняется за время **O(1)**, если у вас есть ссылка на нужный элемент, потому что элементы хранятся в виде узлов, связанных друг с другом.

- **ArrayList** использует массив для хранения элементов, что делает операции вставки и удаления в середине списка дорогими (время выполнения **O(n)**), так как требуется сдвиг элементов.
- **HashSet** — это коллекция, основанная на хеш-таблице, которая не поддерживает порядок элементов и не предоставляет прямой возможности вставки и удаления из середины.
- **Stack** — это структура данных с принципом LIFO (Last In, First Out), которая не подходит для задач, требующих частой работы с серединой списка.

Таким образом, для частых вставок и удалений из середины списка **LinkedList** будет оптимальным выбором.

---
```
Feedback
У LinkedList вставка и удаление из середины списка происходит быстрее, чем у ArrayList.
```
___




**Вам нужно сохранить набор элементов, который автоматически сортируется при добавлении нового элемента. Какую структуру вы выберете?**

- A) HashSet
- B) LinkedHashSet
- C) TreeSet
- D) LinkedList

Правильный ответ — **C) TreeSet**.

**TreeSet** автоматически сортирует элементы при их добавлении. Он реализует интерфейс **Set** и использует сбалансированное бинарное дерево (обычно красно-черное дерево) для хранения элементов, что позволяет автоматически поддерживать их в отсортированном порядке.

- **HashSet** не гарантирует порядок элементов, так как использует хеш-таблицу.
- **LinkedHashSet** сохраняет порядок добавления элементов, но не сортирует их.
- **LinkedList** сохраняет порядок добавления, но не сортирует элементы.

Таким образом, если вам нужно сохранить элементы в отсортированном порядке, вам следует выбрать **TreeSet**.

---
```
Feedback
TreeSet автоматически сортирует элементы.
```
___

**Вам нужна структура данных, которая может эффективно представлять очередь задач, выполняемых по принципу "первым пришел, первым ушел". Что вы выберете?**

- A) Stack
- B) Queue
- C) List
- D) Set

Правильный ответ — **B) Queue**.

**Queue** (очередь) представляет структуру данных, которая работает по принципу **"первым пришел, первым ушел"** (FIFO, First-In-First-Out). Это означает, что элементы добавляются в конец очереди и удаляются с её начала в том порядке, в котором они были добавлены.

- **Stack** работает по принципу **LIFO** (Last-In-First-Out), то есть последний элемент, добавленный в структуру, удаляется первым.
- **List** — это более универсальная структура данных, но она не реализует принцип FIFO.
- **Set** — это коллекция уникальных элементов, но она не поддерживает порядок добавления и удаление элементов по принципу FIFO.

Таким образом, для очереди задач по принципу **"первым пришел, первым ушел"** лучше всего подойдет **Queue**.

---
```
Feedback
Queue представляет структуру данных в порядке FIFO.
```
___




**Вам требуется хранить уникальные элементы без какой-либо дополнительной сортировки или порядка. Какую структуру вы выберете?**

- A) HashSet
- B) TreeSet
- C) LinkedList
- D) Stack

Правильный ответ — **A) HashSet**.

**HashSet** — это структура данных, которая хранит **уникальные элементы** без дополнительной сортировки или сохранения порядка. Она использует хеш-таблицу для хранения элементов, что позволяет эффективно проверять наличие элемента и добавлять новые, при этом не обеспечивает никакого порядка или сортировки.

- **TreeSet** — хранит уникальные элементы, но автоматически сортирует их.
- **LinkedList** — хранит элементы в порядке добавления, но не ограничивает их уникальностью.
- **Stack** — структура данных по принципу LIFO, не предназначенная для хранения уникальных элементов.

Таким образом, для хранения уникальных элементов без сортировки и порядка лучше всего выбрать **HashSet**.

---


**Вам нужно быстро получать значения по уникальному ключу. Что вы выберете?**

- A) HashMap
- B) LinkedHashMap
- C) LinkedList
- D) HashSet

Правильный ответ — **A) HashMap**.

**HashMap** — это структура данных, которая предоставляет очень быстрый доступ к значениям по уникальному ключу. Она использует хеш-таблицу, что позволяет выполнять операции **get** и **put** за время **O(1)** в среднем случае.

- **LinkedHashMap** тоже использует хеш-таблицу и обеспечивает доступ по ключу, но также сохраняет порядок добавления элементов, что может быть полезно в некоторых случаях, но не влияет на время доступа.
- **LinkedList** — это структура данных для хранения элементов в последовательности, где доступ по индексу или ключу работает за **O(n)**.
- **HashSet** — это коллекция для хранения уникальных элементов, но она не работает с ключами и значениями, как **HashMap**.

Таким образом, для быстрого получения значений по уникальному ключу наилучший выбор — **HashMap**.

---



**Основной особенностью этой структуры данных является то, что каждый элемент имеет ссылку на следующий элемент, формируя таким образом последовательность элементов.**

- A) Упорядоченный массив
- B) Связный список (LinkedList)
- C) Красно-черное дерево
- D) Очередь (Queue)

Правильный ответ — **B) Связный список (LinkedList)**.

**Связный список (LinkedList)** — это структура данных, в которой каждый элемент (узел) содержит данные и ссылку на следующий элемент, формируя таким образом последовательность элементов. Существуют два основных типа связных списков: односвязный и двусвязный, в которых элементы могут ссылаться как на следующий, так и на предыдущий элемент.

- **Упорядоченный массив** — это структура данных, где элементы хранятся в массиве в отсортированном порядке, и каждый элемент доступен по индексу.
- **Красно-черное дерево** — это сбалансированное двоичное дерево поиска, где элементы хранятся в виде узлов дерева.
- **Очередь (Queue)** — это структура данных, которая работает по принципу FIFO (первым пришел — первым ушел), но она не хранит элементы с помощью ссылок на следующие элементы, как в связном списке.

Таким образом, **Связный список (LinkedList)** является структурой данных, где каждый элемент имеет ссылку на следующий элемент.

___
```
Feedback
Связный список состоит из нод, каждая из которых содержит данные и ссылку на следующий элемент.
```
___




**Эта структура данных основана на таблице с хеш-функцией, которая отображает ключи на индексы массива, в котором хранятся значения.**

- A) Упорядоченный массив
- B) Двусвязный список
- C) Хеш-таблица (HashMap)
- D) Очередь (Queue)

Правильный ответ — **C) Хеш-таблица (HashMap)**.

**Хеш-таблица (HashMap)** — это структура данных, которая использует хеш-функцию для отображения ключей на индексы массива, в котором хранятся соответствующие значения. Это позволяет эффективно искать, добавлять и удалять элементы с постоянным временем выполнения в среднем случае **O(1)**.

- **Упорядоченный массив** — это структура данных, где элементы хранятся в отсортированном порядке, но не используют хеш-функцию.
- **Двусвязный список** — это структура данных, в которой каждый элемент содержит ссылки на предыдущий и следующий элементы, но не использует хеш-функцию для доступа.
- **Очередь (Queue)** — это структура данных, которая работает по принципу FIFO (первым пришел — первым ушел), но также не использует хеш-функцию.

Таким образом, **Хеш-таблица (HashMap)** — это структура данных, которая использует хеш-функцию для отображения ключей на индексы массива.

---
```
Feedback
Хеш-таблица использует хеш-функцию для отображения ключей на индексы массива, где хранятся значения.
```
___




**Эта структура данных обеспечивает хранение элементов в порядке их добавления и позволяет доступ как к началу, так и к концу коллекции.**

- A) Упорядоченный массив
- B) Декью (Dequeue)
- C) Красно-черное дерево
- D) Хеш-таблица (HashMap)

Правильный ответ — **B) Декью (Dequeue)**.

**Декью (Deque)** — это структура данных, которая позволяет хранить элементы в порядке их добавления и предоставляет доступ как к началу, так и к концу коллекции. Она поддерживает операции добавления и удаления элементов с обеих сторон (как с начала, так и с конца), что делает её гибкой для использования в различных сценариях.

- **Упорядоченный массив** — это структура данных, где элементы хранятся в отсортированном порядке, но она не предоставляет прямой доступ к началу и концу с таким же удобством, как **Deque**.
- **Красно-черное дерево** — это сбалансированное двоичное дерево поиска, которое не предоставляет доступ с обеих сторон, как **Deque**.
- **Хеш-таблица (HashMap)** — это структура данных для хранения пар ключ-значение, которая не организует элементы в порядке их добавления и не предоставляет доступ к началу и концу коллекции.

Таким образом, **Deque** — это структура данных, которая обеспечивает хранение элементов в порядке их добавления и позволяет доступ как к началу, так и к концу коллекции.

---
```
Feedback
Дек позволяет добавлять и удалять элементы как с начала, так и с конца.
```
___




**Эта структура данных хранит элементы в бинарном дереве, где каждый узел имеет два дочерних элемента: один с меньшим значением и один с большим значением.**

- A) Упорядоченный массив
- B) Двусвязный список
- C) Двоичное дерево поиска (Binary Search Tree)
- D) Очередь (Queue)

Правильный ответ — **C) Двоичное дерево поиска (Binary Search Tree)**.

**Двоичное дерево поиска (Binary Search Tree, BST)** — это структура данных, которая хранит элементы в бинарном дереве, где каждый узел имеет два дочерних элемента: один с меньшим значением (слева) и один с большим значением (справа). Это позволяет быстро искать, вставлять и удалять элементы в среднем за **O(log n)** времени, если дерево сбалансировано.

- **Упорядоченный массив** — это массив, в котором элементы хранятся в отсортированном порядке, но это не бинарное дерево.
- **Двусвязный список** — это структура данных, в которой каждый элемент связан с предыдущим и следующим, но она не использует бинарное дерево для организации данных.
- **Очередь (Queue)** — это структура данных, которая работает по принципу FIFO (первым пришел — первым ушел), и не использует бинарное дерево.

Таким образом, **Двоичное дерево поиска (BST)** — это структура данных, которая хранит элементы в бинарном дереве с двумя дочерними узлами для каждого элемента.

---
```
Feedback
Двоичное дерево поиска хранит элементы таким образом, что левое поддерево каждого узла содержит элементы с меньшими значениями, а правое поддерево — с большими значениями.
```
___



**Эта структура данных обеспечивает доступ к элементам на основе "первым пришел, последним ушел" (LIFO), позволяя добавлять и удалять элементы только с верхушки структуры.**

- A) Упорядоченный массив
- B) Двусвязный список
- C) Двоичное дерево поиска (Binary Search Tree)
- D) Стек (Stack)

Правильный ответ — **D) Стек (Stack)**.

**Стек (Stack)** — это структура данных, которая работает по принципу **"первым пришел, последним ушел" (LIFO)**. В стеке элементы добавляются и удаляются только с верхушки, что делает его подходящим для задач, где нужно обработать элементы в обратном порядке их добавления (например, в алгоритмах поиска, обработки выражений и т.д.).

- **Упорядоченный массив** — это структура данных, в которой элементы хранятся в отсортированном порядке, но она не реализует принцип LIFO.
- **Двусвязный список** — это структура данных, которая хранит элементы с ссылками на следующий и предыдущий элементы, но не работает по принципу LIFO.
- **Двоичное дерево поиска (Binary Search Tree)** — это структура данных, которая хранит элементы в бинарном дереве, и не использует принцип LIFO для доступа.

Таким образом, **Стек (Stack)** — это структура данных, обеспечивающая доступ к элементам по принципу **"первым пришел, последним ушел" (LIFO)**.

---
```
Feedback
Стек позволяет добавлять и удалять элементы только с верхушки структуры, обеспечивая таким образом порядок LIFO.
```
___




**Какая структура данных предоставляет следующий метод:
`.containsValue(Object o)`?**  

- A) Set
- B) Map
- C) List
- D) Queue

Правильный ответ — **B) Map**.

Метод **`.containsValue(Object o)`** используется в интерфейсе **Map** для проверки наличия определенного значения в коллекции, где хранятся пары "ключ-значение". Этот метод возвращает **true**, если указанное значение присутствует в коллекции значений, связанных с ключами.

- **Set** — это коллекция, которая хранит уникальные элементы, но не пары "ключ-значение", и не поддерживает метод `.containsValue()`.
- **List** — это коллекция, которая хранит элементы в определенном порядке, но также не работает с парами "ключ-значение" и не имеет метода `.containsValue()`.
- **Queue** — это структура данных для организации элементов по принципу FIFO (первым пришел — первым ушел), и не поддерживает метод `.containsValue()`.

Таким образом, метод **`.containsValue(Object o)`** доступен в **Map**.

---
```
Feedback
Метод .containsValue(Object o) принадлежит интерфейсу Map и позволяет проверить, содержится ли указанное значение в этой карте.
```
___




**Какая структура данных предоставляет следующий метод:
`.addFirst(E e)`?**

- A) Set
- B) Map
- C) List
- D) Deque

Правильный ответ — **D) Deque**.

Метод **`.addFirst(E e)`** используется в интерфейсе **Deque** для добавления элемента в начало очереди. **Deque** (Double-Ended Queue) позволяет добавлять и удалять элементы как с начала, так и с конца коллекции.

- **Set** — это коллекция уникальных элементов, которая не поддерживает методы для добавления элементов в начало или конец.
- **Map** — это коллекция пар "ключ-значение", и она не поддерживает метод **`.addFirst()`**.
- **List** — это коллекция, которая поддерживает порядок элементов, но не имеет метода **`.addFirst()`**. Вместо этого для добавления в начало используется метод **`.add(0, e)`**.
- **Deque** — это структура данных, которая позволяет добавлять и удалять элементы как с начала, так и с конца, и поддерживает метод **`.addFirst()`**.

Таким образом, метод **`.addFirst(E e)`** доступен в **Deque**.

---
```
Feedback
Метод .addFirst(E e) принадлежит интерфейсу Deque, который предоставляет методы для добавления элементов в начало или конец двусторонней очереди.
```
___




**Какая структура данных предоставляет следующий метод: `.get(int index)`?**  

- A) Set
- B) Map
- C) List
- D) Queue

Правильный ответ — **C) List**.

Метод **`.get(int index)`** используется в интерфейсе **List** для получения элемента по индексу. **List** — это коллекция, которая хранит элементы в определенном порядке, и элементы могут быть доступны по индексу.

- **Set** — это коллекция, которая хранит уникальные элементы и не предоставляет доступ к элементам по индексу.
- **Map** — это коллекция пар "ключ-значение", и она не предоставляет метод для получения элементов по индексу, только по ключу.
- **Queue** — это структура данных, которая работает по принципу FIFO (первым пришел, первым ушел), и элементы обычно доступны через методы **poll()**, **peek()**, а не через индекс.

Таким образом, метод **`.get(int index)`** доступен в **List**.

---
```
Feedback
Метод .get(int index) принадлежит интерфейсу List и позволяет получить элемент по указанному индексу.
```
___




**Какая структура данных предоставляет следующий метод: `.poll()`?**  

- A) Set
- B) Map
- C) List
- D) Queue

Правильный ответ — **D) Queue**.

Метод **`.poll()`** используется в интерфейсе **Queue** для извлечения и удаления элемента из начала очереди. Если очередь пуста, метод возвращает **null**. Этот метод является частью коллекции **Queue**, которая организует элементы по принципу **FIFO** (первым пришел, первым ушел).

- **Set** — это коллекция, которая хранит уникальные элементы, но не предоставляет метода **`.poll()`**.
- **Map** — это коллекция пар "ключ-значение", и она не поддерживает метод **`.poll()`**.
- **List** — это коллекция, которая хранит элементы в определенном порядке, но она не использует метод **`.poll()`**.

Таким образом, метод **`.poll()`** доступен в **Queue**.

---
```
Feedback
Метод .poll() принадлежит интерфейсу Queue и позволяет извлечь и удалить головной элемент этой очереди, возвращая null, если очередь пуста.
```
___




**Какая структура данных предоставляет следующий метод: `.push(E item)`?** 

- A) Set
- B) Map
- C) List
- D) Stack

Правильный ответ — **D) Stack**.

Метод **`.push(E item)`** используется в классе **Stack** для добавления элемента в верхнюю часть стека. Стек (Stack) — это структура данных, работающая по принципу **LIFO** (Last In, First Out), то есть последний добавленный элемент извлекается первым.

- **Set** — это коллекция уникальных элементов, и она не поддерживает метод **`.push()`**.
- **Map** — это коллекция пар "ключ-значение", и она не предоставляет метод **`.push()`**.
- **List** — это коллекция, которая хранит элементы в определенном порядке, но вместо метода **`.push()`** для добавления элементов используются другие методы, такие как **`.add()`**.

Таким образом, метод **`.push(E item)`** используется в **Stack**.

---
```
Feedback
Метод .push(E item) принадлежит классу Stack и позволяет добавить элемент на вершину этого стека.
```
___