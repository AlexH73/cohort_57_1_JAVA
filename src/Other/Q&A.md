**Какой из следующих интерфейсов наиболее подходящий для представления упорядоченного списка объектов?**

- A) List
- B) Set
- C) Map
- D) Queue

Правильный ответ — **A) List**.

**List** — это интерфейс, который представляет собой упорядоченный список объектов, где элементы могут быть доступны по индексу, и порядок их добавления сохраняется. Это делает его наилучшим выбором для представления упорядоченного списка объектов.

- **Set** не гарантирует порядок элементов.
    
- **Map** представляет коллекцию пар "ключ-значение", а не просто список объектов.
    
- **Queue** представляет очередь, где элементы обрабатываются в порядке FIFO (First-In-First-Out), что тоже не подходит для упорядоченного списка.

---
````
Feedback

List представляет упорядоченную коллекцию, где элементы могут дублироваться.
````
___


**В какой коллекции порядок элементов гарантированно сохраняется?**

- A) HashSet
- B) LinkedHashSet
- C) TreeSet
- D) HashMap

Правильный ответ — **B) LinkedHashSet**.

**LinkedHashSet** — это коллекция, которая гарантированно сохраняет порядок элементов, в котором они были добавлены. В отличие от **HashSet**, который не сохраняет порядок, и **TreeSet**, который упорядочивает элементы по их естественному порядку или по заданному компаратору, **LinkedHashSet** сохраняет порядок вставки.

- **HashSet** не сохраняет порядок элементов.
    
- **TreeSet** упорядочивает элементы в естественном порядке или с использованием компаратора.
    
- **HashMap** сохраняет порядок по ключам, но сам по себе порядок значений не гарантируется.


Таким образом, **LinkedHashSet** — это коллекция, где порядок элементов сохраняется.

___
````
Feedback

В LinkedHashSet порядок элементов сохраняется в порядке их вставки.
````
___


**Какая коллекция автоматически сортирует элементы?**

- A) HashSet
- B) LinkedHashSet
- C) TreeSet
- D) LinkedList

Правильный ответ — **C) TreeSet**.

**TreeSet** автоматически сортирует элементы. Он реализует интерфейс **Set** и использует дерево для хранения элементов, что позволяет автоматически поддерживать их в отсортированном порядке, используя их естественный порядок или заданный компаратор.

- **HashSet** не сортирует элементы.
    
- **LinkedHashSet** сохраняет порядок добавления элементов, но не сортирует их.
    
- **LinkedList** сохраняет элементы в порядке их добавления, но не сортирует их автоматически.


Таким образом, **TreeSet** — это коллекция, которая автоматически сортирует элементы.
___
````
Feedback

TreeSet автоматически сортирует элементы по естественному порядку или с использованием компаратора.
````
___



***В каком из классов допускаются ключи с null?***

- A) TreeMap
- B) HashMap
- C) LinkedHashMap
- D) HashSet

Правильный ответ — **B) HashMap**.

**HashMap** допускает ключи с **null**. Вы можете использовать **null** в качестве ключа в **HashMap** (максимум один ключ с **null**), и он будет работать корректно. Это не так для **TreeMap**, где ключи должны быть сравнимыми, и **null** не поддерживается, потому что компаратор или естественный порядок не могут быть применены к **null**.

- **TreeMap** не поддерживает ключи с **null**.
- **LinkedHashMap** поддерживает ключи с **null**, как и **HashMap**.
- **HashSet** также поддерживает **null** в качестве элемента, поскольку он основан на **HashMap**.

Таким образом, **HashMap** — это класс, где допускаются ключи с **null**.

___



**Какая структура представляет последовательность элементов в порядке "первым пришел, первым ушел" (FIFO)?**

- A) Stack
- B) Queue
- C) List
- D) Set

Правильный ответ — **Queue**.

**Queue** (очередь) представляет структуру данных, которая работает по принципу "первым пришел, первым ушел" (FIFO, First-In-First-Out). Это означает, что элементы, добавленные в очередь первыми, будут удаляться первыми.

- **Queue** — это интерфейс, реализующий структуру данных для обработки элементов в порядке их добавления (FIFO).
- Другие структуры данных, такие как **Stack** (стек), работают по принципу LIFO (Last-In-First-Out), где последний элемент, добавленный в структуру, удаляется первым.

___
```
Feedback
Очередь (Queue) представляет структуру данных в порядке FIFO.
```
___




**Какой класс представляет структуру данных "последний пришел, первым ушел" (LIFO)?**

- A) Stack
- B) Queue
- C) ArrayList
- D) TreeSet

Правильный ответ — **Stack**.

**Stack** (стек) представляет структуру данных, которая работает по принципу "последний пришел, первым ушел" (LIFO, Last-In-First-Out). Это означает, что последний элемент, добавленный в стек, будет удалён первым.

- **Stack** — класс, реализующий структуру данных стек, где элементы добавляются и удаляются с одного конца, называемого вершиной стека.

Стеки используются в различных задачах, таких как управление вызовами функций, обработка обратных польских записей и многие другие.

---
```
Feedback
Stack представляет структуру данных в порядке LIFO.
```
---



**Какой из классов реализует двусвязный список?**

- A) ArrayList
- B) LinkedList
- C) HashSet
- D) TreeSet

Правильный ответ — **LinkedList**.

**LinkedList** реализует двусвязный список. В двусвязном списке каждый элемент (узел) содержит ссылку как на следующий, так и на предыдущий элемент, что позволяет эффективно перемещаться в обоих направлениях.

- **LinkedList** — это класс, который реализует интерфейсы **List** и **Deque**, и представляет собой двусвязный список.
- Другие структуры данных, такие как **ArrayList**, основаны на массиве и не являются двусвязными списками.

Таким образом, **LinkedList** — это класс, который реализует двусвязный список.

---




**Что характерно для Set?**

- A) Сохраняет порядок элементов
- B) Позволяет дублирование элементов
- C) Не допускает дублирование элементов
- D) Использует ключ-значение

Правильный ответ — **C) Не допускает дублирование элементов**.

**Set** — это коллекция, которая **не допускает дублирование элементов**. В отличие от **List**, где могут быть повторяющиеся элементы, в **Set** каждый элемент уникален. Однако порядок элементов в **Set** не гарантируется, если только это не специфическая реализация, такая как **LinkedHashSet**, которая сохраняет порядок добавления.

- **A) Сохраняет порядок элементов** — не всегда, это зависит от реализации (например, **HashSet** не сохраняет порядок, а **LinkedHashSet** сохраняет).
- **B) Позволяет дублирование элементов** — это неверно для **Set**, так как **Set** не допускает дублирования.
- **D) Использует ключ-значение** — это свойственно структурам данных, таким как **Map**, а не **Set**.

Таким образом, **Set** — это коллекция, которая не допускает дублирования элементов.

---



**Какой интерфейс использует пары "ключ-значение"?**

- A) List
- B) Set
- C) Map
- D) Queue

Правильный ответ — **C) Map**.

**Map** — это интерфейс, который представляет коллекцию пар "ключ-значение". В **Map** каждый ключ связан с одним значением, и каждый ключ в коллекции уникален. Это позволяет эффективно искать значения по ключу.

- **List** — представляет коллекцию элементов, где порядок элементов важен, но не поддерживает пару "ключ-значение".
- **Set** — представляет коллекцию уникальных элементов, но не использует пару "ключ-значение".
- **Queue** — представляет очередь, где элементы обрабатываются в порядке FIFO, и также не использует пару "ключ-значение".

Таким образом, для пар "ключ-значение" используется интерфейс **Map**.

---



**Какой из классов обеспечивает постоянное время выполнения для основных операций, таких как add, remove и contains?**

- A) TreeSet
- B) HashSet
- C) LinkedList
- D) TreeMap

Правильный ответ — **B) HashSet**.

**HashSet** обеспечивает постоянное время выполнения (O(1)) для основных операций, таких как **add**, **remove** и **contains** в среднем случае. Это связано с тем, что **HashSet** использует хеш-таблицу для хранения элементов, что позволяет быстро находить элементы, добавлять их и удалять.

- **TreeSet** имеет логарифмическое время выполнения для основных операций (O(log n)), так как элементы хранятся в отсортированном порядке.
- **LinkedList** имеет линейное время выполнения (O(n)) для операций **add**, **remove** и **contains** в худшем случае, так как элементы должны быть пройдены по списку.
- **TreeMap** также имеет логарифмическое время выполнения для основных операций (O(log n)).

Таким образом, **HashSet** обеспечивает постоянное время выполнения для основных операций в среднем случае.

---
```
Feedback
HashSet обычно предоставляет постоянное время выполнения для основных операций за счет использования хеш-таблицы.
```
---