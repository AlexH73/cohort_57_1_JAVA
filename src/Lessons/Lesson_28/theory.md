

# Урок 28: ArrayList


---
## JCF

**Java Collection Framework (JCF)** - множество классов и интерфейсов которые реализуют наиболее часто используемые структуры данных. Эти все структуры работают с наборами данных и имеют уже реализованные методы на все типовые случаи жизни. Выбор той или иной структуры основывается на знании/понимании/оценке затрат на вычислительную сложность для тех операций, которые с этими структурами данных планируется чаще всего производить.

JCF состоит из двух больших подразделов: Map и Collection. Мы начинаем наше изучение с коллекций.

Интерфейс Collection расширяет интерфейс Iterable, т. е. все коллекции итерируемые. Интерфейс Collection определяет некоторый основной набор методов для работы с коллекциями данных. Например, добавление, удаление, поиск, получение колличества элементов в коллекции и т. д.

Есть множество интерфейсов расширяющих интерфейс Collection. Мы рассмотрим интерфейсы Set и List. И начнем с интерфейса List. Интерфейс List определяет коллекции элементы которых имеют индексы, т. е. некий аналог массива, но не имеющий ограничения по размеру. Соответственно в интерфейсе List, помимо методов унаследованных от Iterable и Collection, определены методы работающие с индексами. Например:

-   вставка элемента по индексу,
-   удаление по индексу,
-   получение элемента по индексу,
-   поиск индекса заданного аргумента и т. п.

Одной из имплементаций интерфейса List является класс ArrayList. Для реализации функциональности интерфейса List, ArrayList инкапсулирует в себе массив некоторого начального размера. Когда этот массив полностью заполняется, то его элементы копируются в новый массив, но уже большего размера. И теперь ждем когда заполнится новый массив и т.д. Обычно почсле нескольких итераций, длина массива "устаканивается" и далее ArrayList имеет достаточно стабильный размер (size). Т. е. простым языком ArrayList представляет из себя "резиновый массив".

# Класс ArrayList

Основное неудобство использования массивов - необходимость точно определить размер, до создания массива. Всякий раз когда в ходе работы программы возникает необходимость увеличить размер массива, мы должны выполнить стандартный набор действий:

1.  создать новый массив нужного размера
2.  перенести все эллеенты из старого массива в новый
3.  изменить ссылку

Задача класса `java.util.ArrayList` - автоматизировать эти шаги, сделая их прозрачными для программиста иными словами реализовать в Java _динамический массив_.  
С точки зрения использования, мы можем не задумываться, что внутри ArrayList есть массив, в который добавляются или удаляяются эллеметы, мы просто говорим программе добавить элемент, найти, удалить элемент и т.д. Всю работу выполняет ArrayList

## Пример использования

-   создать объект ArrayList

```java
ArrayList<String> list = new ArrayList<>();
```

## JCF

**Java Collection Framework (JCF)** - множество классов и интерфейсов которые реализуют наиболее часто используемые структуры данных. Эти все структуры работают с наборами данных и имеют уже реализованные методы на все типовые случаи жизни. Выбор той или иной структуры основывается на знании/понимании/оценке затрат на вычислительную сложность для тех операций, которые с этими структурами данных планируется чаще всего производить.

JCF состоит из двух больших подразделов: Map и Collection. Мы начинаем наше изучение с коллекций.

Интерфейс Collection расширяет интерфейс Iterable, т. е. все коллекции итерируемые. Интерфейс Collection определяет некоторый основной набор методов для работы с коллекциями данных. Например, добавление, удаление, поиск, получение колличества элементов в коллекции и т. д.

Есть множество интерфейсов расширяющих интерфейс Collection. Мы рассмотрим интерфейсы Set и List. И начнем с интерфейса List. Интерфейс List определяет коллекции элементы которых имеют индексы, т. е. некий аналог массива, но не имеющий ограничения по размеру. Соответственно в интерфейсе List, помимо методов унаследованных от Iterable и Collection, определены методы работающие с индексами. Например:

-   вставка элемента по индексу,
-   удаление по индексу,
-   получение элемента по индексу,
-   поиск индекса заданного аргумента и т. п.

Одной из имплементаций интерфейса List является класс ArrayList. Для реализации функциональности интерфейса List, ArrayList инкапсулирует в себе массив некоторого начального размера. Когда этот массив полностью заполняется, то его элементы копируются в новый массив, но уже большего размера. И теперь ждем когда заполнится новый массив и т.д. Обычно почсле нескольких итераций, длина массива "устаканивается" и далее ArrayList имеет достаточно стабильный размер (size). Т. е. простым языком ArrayList представляет из себя "резиновый массив".

# Класс ArrayList

Основное неудобство использования массивов - необходимость точно определить размер, до создания массива. Всякий раз когда в ходе работы программы возникает необходимость увеличить размер массива, мы должны выполнить стандартный набор действий:

1.  создать новый массив нужного размера
2.  перенести все эллеенты из старого массива в новый
3.  изменить ссылку

Задача класса `java.util.ArrayList` - автоматизировать эти шаги, сделая их прозрачными для программиста иными словами реализовать в Java _динамический массив_.  
С точки зрения использования, мы можем не задумываться, что внутри ArrayList есть массив, в который добавляются или удаляяются эллеметы, мы просто говорим программе добавить элемент, найти, удалить элемент и т.д. Всю работу выполняет ArrayList

## Пример использования

-   создать объект ArrayList

```java
ArrayList<String> list = new ArrayList<>();
```

## JCF

**Java Collection Framework (JCF)** - множество классов и интерфейсов которые реализуют наиболее часто используемые структуры данных. Эти все структуры работают с наборами данных и имеют уже реализованные методы на все типовые случаи жизни. Выбор той или иной структуры основывается на знании/понимании/оценке затрат на вычислительную сложность для тех операций, которые с этими структурами данных планируется чаще всего производить.

JCF состоит из двух больших подразделов: Map и Collection. Мы начинаем наше изучение с коллекций.

Интерфейс Collection расширяет интерфейс Iterable, т. е. все коллекции итерируемые. Интерфейс Collection определяет некоторый основной набор методов для работы с коллекциями данных. Например, добавление, удаление, поиск, получение колличества элементов в коллекции и т. д.

Есть множество интерфейсов расширяющих интерфейс Collection. Мы рассмотрим интерфейсы Set и List. И начнем с интерфейса List. Интерфейс List определяет коллекции элементы которых имеют индексы, т. е. некий аналог массива, но не имеющий ограничения по размеру. Соответственно в интерфейсе List, помимо методов унаследованных от Iterable и Collection, определены методы работающие с индексами. Например:

-   вставка элемента по индексу,
-   удаление по индексу,
-   получение элемента по индексу,
-   поиск индекса заданного аргумента и т. п.

Одной из имплементаций интерфейса List является класс ArrayList. Для реализации функциональности интерфейса List, ArrayList инкапсулирует в себе массив некоторого начального размера. Когда этот массив полностью заполняется, то его элементы копируются в новый массив, но уже большего размера. И теперь ждем когда заполнится новый массив и т.д. Обычно почсле нескольких итераций, длина массива "устаканивается" и далее ArrayList имеет достаточно стабильный размер (size). Т. е. простым языком ArrayList представляет из себя "резиновый массив".

# Класс ArrayList

Основное неудобство использования массивов - необходимость точно определить размер, до создания массива. Всякий раз когда в ходе работы программы возникает необходимость увеличить размер массива, мы должны выполнить стандартный набор действий:

1.  создать новый массив нужного размера
2.  перенести все эллеенты из старого массива в новый
3.  изменить ссылку

Задача класса `java.util.ArrayList` - автоматизировать эти шаги, сделая их прозрачными для программиста иными словами реализовать в Java _динамический массив_.  
С точки зрения использования, мы можем не задумываться, что внутри ArrayList есть массив, в который добавляются или удаляяются эллеметы, мы просто говорим программе добавить элемент, найти, удалить элемент и т.д. Всю работу выполняет ArrayList

## Пример использования

-   создать объект ArrayList

```java
ArrayList<String> list = new ArrayList<>();
```

## JCF

**Java Collection Framework (JCF)** - множество классов и интерфейсов которые реализуют наиболее часто используемые структуры данных. Эти все структуры работают с наборами данных и имеют уже реализованные методы на все типовые случаи жизни. Выбор той или иной структуры основывается на знании/понимании/оценке затрат на вычислительную сложность для тех операций, которые с этими структурами данных планируется чаще всего производить.

JCF состоит из двух больших подразделов: Map и Collection. Мы начинаем наше изучение с коллекций.

Интерфейс Collection расширяет интерфейс Iterable, т. е. все коллекции итерируемые. Интерфейс Collection определяет некоторый основной набор методов для работы с коллекциями данных. Например, добавление, удаление, поиск, получение колличества элементов в коллекции и т. д.

Есть множество интерфейсов расширяющих интерфейс Collection. Мы рассмотрим интерфейсы Set и List. И начнем с интерфейса List. Интерфейс List определяет коллекции элементы которых имеют индексы, т. е. некий аналог массива, но не имеющий ограничения по размеру. Соответственно в интерфейсе List, помимо методов унаследованных от Iterable и Collection, определены методы работающие с индексами. Например:

-   вставка элемента по индексу,
-   удаление по индексу,
-   получение элемента по индексу,
-   поиск индекса заданного аргумента и т. п.

Одной из имплементаций интерфейса List является класс ArrayList. Для реализации функциональности интерфейса List, ArrayList инкапсулирует в себе массив некоторого начального размера. Когда этот массив полностью заполняется, то его элементы копируются в новый массив, но уже большего размера. И теперь ждем когда заполнится новый массив и т.д. Обычно почсле нескольких итераций, длина массива "устаканивается" и далее ArrayList имеет достаточно стабильный размер (size). Т. е. простым языком ArrayList представляет из себя "резиновый массив".

# Класс ArrayList

Основное неудобство использования массивов - необходимость точно определить размер, до создания массива. Всякий раз когда в ходе работы программы возникает необходимость увеличить размер массива, мы должны выполнить стандартный набор действий:

1.  создать новый массив нужного размера
2.  перенести все эллеенты из старого массива в новый
3.  изменить ссылку

Задача класса `java.util.ArrayList` - автоматизировать эти шаги, сделая их прозрачными для программиста иными словами реализовать в Java _динамический массив_.  
С точки зрения использования, мы можем не задумываться, что внутри ArrayList есть массив, в который добавляются или удаляяются эллеметы, мы просто говорим программе добавить элемент, найти, удалить элемент и т.д. Всю работу выполняет ArrayList

## Пример использования

-   создать объект ArrayList

```java
ArrayList<String> list = new ArrayList<>();
```

## JCF

**Java Collection Framework (JCF)** - множество классов и интерфейсов которые реализуют наиболее часто используемые структуры данных. Эти все структуры работают с наборами данных и имеют уже реализованные методы на все типовые случаи жизни. Выбор той или иной структуры основывается на знании/понимании/оценке затрат на вычислительную сложность для тех операций, которые с этими структурами данных планируется чаще всего производить.

JCF состоит из двух больших подразделов: Map и Collection. Мы начинаем наше изучение с коллекций.

Интерфейс Collection расширяет интерфейс Iterable, т. е. все коллекции итерируемые. Интерфейс Collection определяет некоторый основной набор методов для работы с коллекциями данных. Например, добавление, удаление, поиск, получение колличества элементов в коллекции и т. д.

Есть множество интерфейсов расширяющих интерфейс Collection. Мы рассмотрим интерфейсы Set и List. И начнем с интерфейса List. Интерфейс List определяет коллекции элементы которых имеют индексы, т. е. некий аналог массива, но не имеющий ограничения по размеру. Соответственно в интерфейсе List, помимо методов унаследованных от Iterable и Collection, определены методы работающие с индексами. Например:

-   вставка элемента по индексу,
-   удаление по индексу,
-   получение элемента по индексу,
-   поиск индекса заданного аргумента и т. п.

Одной из имплементаций интерфейса List является класс ArrayList. Для реализации функциональности интерфейса List, ArrayList инкапсулирует в себе массив некоторого начального размера. Когда этот массив полностью заполняется, то его элементы копируются в новый массив, но уже большего размера. И теперь ждем когда заполнится новый массив и т.д. Обычно почсле нескольких итераций, длина массива "устаканивается" и далее ArrayList имеет достаточно стабильный размер (size). Т. е. простым языком ArrayList представляет из себя "резиновый массив".

# Класс ArrayList

Основное неудобство использования массивов - необходимость точно определить размер, до создания массива. Всякий раз когда в ходе работы программы возникает необходимость увеличить размер массива, мы должны выполнить стандартный набор действий:

1.  создать новый массив нужного размера
2.  перенести все эллеенты из старого массива в новый
3.  изменить ссылку

Задача класса `java.util.ArrayList` - автоматизировать эти шаги, сделая их прозрачными для программиста иными словами реализовать в Java _динамический массив_.  
С точки зрения использования, мы можем не задумываться, что внутри ArrayList есть массив, в который добавляются или удаляяются эллеметы, мы просто говорим программе добавить элемент, найти, удалить элемент и т.д. Всю работу выполняет ArrayList

## Пример использования

-   создать объект ArrayList

```java
ArrayList<String> list = new ArrayList<>();
```

## JCF

**Java Collection Framework (JCF)** - множество классов и интерфейсов которые реализуют наиболее часто используемые структуры данных. Эти все структуры работают с наборами данных и имеют уже реализованные методы на все типовые случаи жизни. Выбор той или иной структуры основывается на знании/понимании/оценке затрат на вычислительную сложность для тех операций, которые с этими структурами данных планируется чаще всего производить.

JCF состоит из двух больших подразделов: Map и Collection. Мы начинаем наше изучение с коллекций.

Интерфейс Collection расширяет интерфейс Iterable, т. е. все коллекции итерируемые. Интерфейс Collection определяет некоторый основной набор методов для работы с коллекциями данных. Например, добавление, удаление, поиск, получение колличества элементов в коллекции и т. д.

Есть множество интерфейсов расширяющих интерфейс Collection. Мы рассмотрим интерфейсы Set и List. И начнем с интерфейса List. Интерфейс List определяет коллекции элементы которых имеют индексы, т. е. некий аналог массива, но не имеющий ограничения по размеру. Соответственно в интерфейсе List, помимо методов унаследованных от Iterable и Collection, определены методы работающие с индексами. Например:

-   вставка элемента по индексу,
-   удаление по индексу,
-   получение элемента по индексу,
-   поиск индекса заданного аргумента и т. п.

Одной из имплементаций интерфейса List является класс ArrayList. Для реализации функциональности интерфейса List, ArrayList инкапсулирует в себе массив некоторого начального размера. Когда этот массив полностью заполняется, то его элементы копируются в новый массив, но уже большего размера. И теперь ждем когда заполнится новый массив и т.д. Обычно почсле нескольких итераций, длина массива "устаканивается" и далее ArrayList имеет достаточно стабильный размер (size). Т. е. простым языком ArrayList представляет из себя "резиновый массив".

# Класс ArrayList

Основное неудобство использования массивов - необходимость точно определить размер, до создания массива. Всякий раз когда в ходе работы программы возникает необходимость увеличить размер массива, мы должны выполнить стандартный набор действий:

1.  создать новый массив нужного размера
2.  перенести все эллеенты из старого массива в новый
3.  изменить ссылку

Задача класса `java.util.ArrayList` - автоматизировать эти шаги, сделая их прозрачными для программиста иными словами реализовать в Java _динамический массив_.  
С точки зрения использования, мы можем не задумываться, что внутри ArrayList есть массив, в который добавляются или удаляяются эллеметы, мы просто говорим программе добавить элемент, найти, удалить элемент и т.д. Всю работу выполняет ArrayList

## Пример использования

-   создать объект ArrayList

```java
ArrayList<String> list = new ArrayList<>();
```

## JCF

**Java Collection Framework (JCF)** - множество классов и интерфейсов которые реализуют наиболее часто используемые структуры данных. Эти все структуры работают с наборами данных и имеют уже реализованные методы на все типовые случаи жизни. Выбор той или иной структуры основывается на знании/понимании/оценке затрат на вычислительную сложность для тех операций, которые с этими структурами данных планируется чаще всего производить.

JCF состоит из двух больших подразделов: Map и Collection. Мы начинаем наше изучение с коллекций.

Интерфейс Collection расширяет интерфейс Iterable, т. е. все коллекции итерируемые. Интерфейс Collection определяет некоторый основной набор методов для работы с коллекциями данных. Например, добавление, удаление, поиск, получение колличества элементов в коллекции и т. д.

Есть множество интерфейсов расширяющих интерфейс Collection. Мы рассмотрим интерфейсы Set и List. И начнем с интерфейса List. Интерфейс List определяет коллекции элементы которых имеют индексы, т. е. некий аналог массива, но не имеющий ограничения по размеру. Соответственно в интерфейсе List, помимо методов унаследованных от Iterable и Collection, определены методы работающие с индексами. Например:

-   вставка элемента по индексу,
-   удаление по индексу,
-   получение элемента по индексу,
-   поиск индекса заданного аргумента и т. п.

Одной из имплементаций интерфейса List является класс ArrayList. Для реализации функциональности интерфейса List, ArrayList инкапсулирует в себе массив некоторого начального размера. Когда этот массив полностью заполняется, то его элементы копируются в новый массив, но уже большего размера. И теперь ждем когда заполнится новый массив и т.д. Обычно почсле нескольких итераций, длина массива "устаканивается" и далее ArrayList имеет достаточно стабильный размер (size). Т. е. простым языком ArrayList представляет из себя "резиновый массив".

# Класс ArrayList

Основное неудобство использования массивов - необходимость точно определить размер, до создания массива. Всякий раз когда в ходе работы программы возникает необходимость увеличить размер массива, мы должны выполнить стандартный набор действий:

1.  создать новый массив нужного размера
2.  перенести все эллеенты из старого массива в новый
3.  изменить ссылку

Задача класса `java.util.ArrayList` - автоматизировать эти шаги, сделая их прозрачными для программиста иными словами реализовать в Java _динамический массив_.  
С точки зрения использования, мы можем не задумываться, что внутри ArrayList есть массив, в который добавляются или удаляяются эллеметы, мы просто говорим программе добавить элемент, найти, удалить элемент и т.д. Всю работу выполняет ArrayList

## Пример использования

-   создать объект ArrayList

```java
ArrayList<String> list = new ArrayList<>();
```

## JCF

**Java Collection Framework (JCF)** - множество классов и интерфейсов которые реализуют наиболее часто используемые структуры данных. Эти все структуры работают с наборами данных и имеют уже реализованные методы на все типовые случаи жизни. Выбор той или иной структуры основывается на знании/понимании/оценке затрат на вычислительную сложность для тех операций, которые с этими структурами данных планируется чаще всего производить.

JCF состоит из двух больших подразделов: Map и Collection. Мы начинаем наше изучение с коллекций.

Интерфейс Collection расширяет интерфейс Iterable, т. е. все коллекции итерируемые. Интерфейс Collection определяет некоторый основной набор методов для работы с коллекциями данных. Например, добавление, удаление, поиск, получение колличества элементов в коллекции и т. д.

Есть множество интерфейсов расширяющих интерфейс Collection. Мы рассмотрим интерфейсы Set и List. И начнем с интерфейса List. Интерфейс List определяет коллекции элементы которых имеют индексы, т. е. некий аналог массива, но не имеющий ограничения по размеру. Соответственно в интерфейсе List, помимо методов унаследованных от Iterable и Collection, определены методы работающие с индексами. Например:

-   вставка элемента по индексу,
-   удаление по индексу,
-   получение элемента по индексу,
-   поиск индекса заданного аргумента и т. п.

Одной из имплементаций интерфейса List является класс ArrayList. Для реализации функциональности интерфейса List, ArrayList инкапсулирует в себе массив некоторого начального размера. Когда этот массив полностью заполняется, то его элементы копируются в новый массив, но уже большего размера. И теперь ждем когда заполнится новый массив и т.д. Обычно почсле нескольких итераций, длина массива "устаканивается" и далее ArrayList имеет достаточно стабильный размер (size). Т. е. простым языком ArrayList представляет из себя "резиновый массив".

# Класс ArrayList

Основное неудобство использования массивов - необходимость точно определить размер, до создания массива. Всякий раз когда в ходе работы программы возникает необходимость увеличить размер массива, мы должны выполнить стандартный набор действий:

1.  создать новый массив нужного размера
2.  перенести все эллеенты из старого массива в новый
3.  изменить ссылку

Задача класса `java.util.ArrayList` - автоматизировать эти шаги, сделая их прозрачными для программиста иными словами реализовать в Java _динамический массив_.  
С точки зрения использования, мы можем не задумываться, что внутри ArrayList есть массив, в который добавляются или удаляяются эллеметы, мы просто говорим программе добавить элемент, найти, удалить элемент и т.д. Всю работу выполняет ArrayList

## Пример использования

-   создать объект ArrayList

```java
ArrayList<String> list = new ArrayList<>();
```

## JCF

**Java Collection Framework (JCF)** - множество классов и интерфейсов которые реализуют наиболее часто используемые структуры данных. Эти все структуры работают с наборами данных и имеют уже реализованные методы на все типовые случаи жизни. Выбор той или иной структуры основывается на знании/понимании/оценке затрат на вычислительную сложность для тех операций, которые с этими структурами данных планируется чаще всего производить.

JCF состоит из двух больших подразделов: Map и Collection. Мы начинаем наше изучение с коллекций.

Интерфейс Collection расширяет интерфейс Iterable, т. е. все коллекции итерируемые. Интерфейс Collection определяет некоторый основной набор методов для работы с коллекциями данных. Например, добавление, удаление, поиск, получение колличества элементов в коллекции и т. д.

Есть множество интерфейсов расширяющих интерфейс Collection. Мы рассмотрим интерфейсы Set и List. И начнем с интерфейса List. Интерфейс List определяет коллекции элементы которых имеют индексы, т. е. некий аналог массива, но не имеющий ограничения по размеру. Соответственно в интерфейсе List, помимо методов унаследованных от Iterable и Collection, определены методы работающие с индексами. Например:

-   вставка элемента по индексу,
-   удаление по индексу,
-   получение элемента по индексу,
-   поиск индекса заданного аргумента и т. п.

Одной из имплементаций интерфейса List является класс ArrayList. Для реализации функциональности интерфейса List, ArrayList инкапсулирует в себе массив некоторого начального размера. Когда этот массив полностью заполняется, то его элементы копируются в новый массив, но уже большего размера. И теперь ждем когда заполнится новый массив и т.д. Обычно почсле нескольких итераций, длина массива "устаканивается" и далее ArrayList имеет достаточно стабильный размер (size). Т. е. простым языком ArrayList представляет из себя "резиновый массив".

# Класс ArrayList

Основное неудобство использования массивов - необходимость точно определить размер, до создания массива. Всякий раз когда в ходе работы программы возникает необходимость увеличить размер массива, мы должны выполнить стандартный набор действий:

1.  создать новый массив нужного размера
2.  перенести все эллеенты из старого массива в новый
3.  изменить ссылку

Задача класса `java.util.ArrayList` - автоматизировать эти шаги, сделая их прозрачными для программиста иными словами реализовать в Java _динамический массив_.  
С точки зрения использования, мы можем не задумываться, что внутри ArrayList есть массив, в который добавляются или удаляяются эллеметы, мы просто говорим программе добавить элемент, найти, удалить элемент и т.д. Всю работу выполняет ArrayList

## Пример использования

-   создать объект ArrayList

```java
ArrayList<String> list = new ArrayList<>();
```

## JCF

**Java Collection Framework (JCF)** - множество классов и интерфейсов которые реализуют наиболее часто используемые структуры данных. Эти все структуры работают с наборами данных и имеют уже реализованные методы на все типовые случаи жизни. Выбор той или иной структуры основывается на знании/понимании/оценке затрат на вычислительную сложность для тех операций, которые с этими структурами данных планируется чаще всего производить.

JCF состоит из двух больших подразделов: Map и Collection. Мы начинаем наше изучение с коллекций.

Интерфейс Collection расширяет интерфейс Iterable, т. е. все коллекции итерируемые. Интерфейс Collection определяет некоторый основной набор методов для работы с коллекциями данных. Например, добавление, удаление, поиск, получение колличества элементов в коллекции и т. д.

Есть множество интерфейсов расширяющих интерфейс Collection. Мы рассмотрим интерфейсы Set и List. И начнем с интерфейса List. Интерфейс List определяет коллекции элементы которых имеют индексы, т. е. некий аналог массива, но не имеющий ограничения по размеру. Соответственно в интерфейсе List, помимо методов унаследованных от Iterable и Collection, определены методы работающие с индексами. Например:

-   вставка элемента по индексу,
-   удаление по индексу,
-   получение элемента по индексу,
-   поиск индекса заданного аргумента и т. п.

Одной из имплементаций интерфейса List является класс ArrayList. Для реализации функциональности интерфейса List, ArrayList инкапсулирует в себе массив некоторого начального размера. Когда этот массив полностью заполняется, то его элементы копируются в новый массив, но уже большего размера. И теперь ждем когда заполнится новый массив и т.д. Обычно почсле нескольких итераций, длина массива "устаканивается" и далее ArrayList имеет достаточно стабильный размер (size). Т. е. простым языком ArrayList представляет из себя "резиновый массив".

# Класс ArrayList

Основное неудобство использования массивов - необходимость точно определить размер, до создания массива. Всякий раз когда в ходе работы программы возникает необходимость увеличить размер массива, мы должны выполнить стандартный набор действий:

1.  создать новый массив нужного размера
2.  перенести все эллеенты из старого массива в новый
3.  изменить ссылку

Задача класса `java.util.ArrayList` - автоматизировать эти шаги, сделая их прозрачными для программиста иными словами реализовать в Java _динамический массив_.  
С точки зрения использования, мы можем не задумываться, что внутри ArrayList есть массив, в который добавляются или удаляяются эллеметы, мы просто говорим программе добавить элемент, найти, удалить элемент и т.д. Всю работу выполняет ArrayList

## Пример использования

-   создать объект ArrayList

```java
ArrayList<String> list = new ArrayList<>();
```
