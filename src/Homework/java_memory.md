                                     Память в Java устроена следующим образом
    
    она управляется автоматически с помощью сборщика мусора (Garbage Collector, GC)
    и делится на несколько основных областей. Рассмотрим основные компоненты памяти в JVM (Java Virtual Machine).
                                          1.Разделение памяти в Java
    Основные области памяти:
    * Heap (Куча) – основное место хранения объектов.
    * Stack (Стек) – область памяти для вызовов методов и локальных переменных.
    * Metaspace (Метапространство, до Java 8 – Permanent Generation) – хранит метаданные классов.
    * Thread Area (Область потока) – хранит данные для работы потоков.
    * PC Register (Счётчик команд) – содержит адрес текущей инструкции для каждого потока.
    * Native Stack (Стек нативных методов) – используется для вызова нативного кода (JNI).

                                    2.Подробное объяснение областей памяти
    1. Heap (Куча) – хранение объектов
    Heap – это основная область памяти, где создаются все объекты в Java.

    *Каждый объект создаётся в куче и остаётся там, пока на него есть ссылки.
    *Когда объект становится неиспользуемым, Garbage Collector (GC) удаляет его.
    *Heap делится на:
        *Young Generation – молодое поколение (сюда попадают новые объекты).
        *Eden Space – пространство, где создаются новые объекты.
        *Survivor Spaces (S0, S1) – объекты, пережившие несколько сборок мусора.
        *Old Generation (Tenured Space) – сюда перемещаются старые объекты, которые пережили несколько сборок мусора.
        *Humongous Space – хранение больших объектов (в G1 GC).

    Пример хранения объекта в куче:
```java 
public class Main {
    public static void main(String[] args) {
        Person person = new Person("Александр"); // Объект в Heap
    }
}

    //Здесь объект Person создаётся в куче, а ссылка person хранится в стеке.
```

                                     2.Stack (Стек) – локальные переменные и вызовы методов
    Stack Memory используется для хранения:

    *Локальных переменных метода.
    *Ссылок на объекты в куче.
    *Вызовов методов (кадры стека).
    
    Пример работы стека:

```java
public class StackExample {
    public static void main(String[] args) {
        int a = 10; // Переменная в стеке
        int b = add(a, 5); // Вызов метода -> новый фрейм в стеке
}

static int add(int x, int y) { 
        int sum = x + y; // Локальная переменная sum в стеке
        return sum; // Возврат значения
    }
}
```
    Как выглядит стек во время выполнения:

    *Вызов main(), создаётся стековый фрейм.
    *Вызов add(), создаётся новый фрейм.
    *Возврат sum, фрейм add() уничтожается.
    *Завершение main(), стек очищается.

                                    3. Metaspace (Метапространство)
    Metaspace (с Java 8) хранит:

    *Метаданные классов (структура, поля, методы).
    *Пул строк (String Pool).
    *Статические переменные классов.

    Пример:

```java
public class Test {
    static int number = 100; // Статическая переменная (Metaspace)
}
    // Переменная number будет храниться в Metaspace, так как это static
```
                                    4. Thread Area (Область потока)
    Каждый поток в Java имеет свой стек, PC-регистр и область для выполнения инструкций. 
    Это обеспечивает безопасность потоков, так как они не могут изменять память друг друга.


                                    5. PC Register (Счётчик команд)
    *Хранит адрес текущей инструкции для каждого потока.
    *Используется JVM для управления выполнением байт-кода.

                                    6. Native Stack (Стек нативных методов)
    *Используется для вызовов методов через JNI (Java Native Interface), 
    *когда Java взаимодействует с нативным кодом (например, C/C++).


                                    3. Как работает сборщик мусора (Garbage Collector)?
    Garbage Collector (GC) автоматически освобождает память, удаляя неиспользуемые объекты.

                Основные алгоритмы GC:
    * Mark and Sweep – помечает живые объекты, удаляет ненужные.
    * Generational GC – делит память на поколения (Young, Old) для оптимизации.
    * Reference Counting – следит за ссылками на объект.

    Пример работы GC:

```java
public class GarbageExample {
    public static void main(String[] args) {
        Person p1 = new Person("Алекс");
        p1 = null; // Удаление ссылки, объект помечается как "мусор"
        System.gc(); // Запрос GC (необязательно)
    }
}
    // При p1 = null; объект Person становится доступным для удаления GC.
```
                                    Вывод
    * Heap (Куча) – для объектов, делится на Young и Old Generation.
    * Stack (Стек) – для локальных переменных и вызовов методов.
    * Metaspace – для метаданных классов, статических переменных.
    * Thread Area – выделяется для каждого потока.
    * PC Register – хранит текущую инструкцию потока.
    * Native Stack – используется для вызова нативного кода.
    
    Сборщик мусора (GC) автоматически управляет памятью, удаляя неиспользуемые объекты.




































