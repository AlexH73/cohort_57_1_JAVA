package Homework.lesson_39;

// * Домашнее задание: Бинарный поиск первого и последнего вхождения
// * Цель данного задания – реализовать два метода, которые находят первое и последнее вхождение
// * заданного элемента (target) в отсортированном массиве с использованием бинарного поиска.
// * Вам необходимо реализовать следующие два метода:
// *     <code>int firstCount(int[] arr, int target)</code> – метод, который должен возвращать индекс первого вхождения
// *     элемента <code>target</code> в отсортированном массиве <code>arr</code>.
// *     <code>int lastCount(int[] arr, int target)</code> – метод, который должен возвращать индекс последнего вхождения
// *     элемента <code>target</code> в отсортированном массиве <code>arr</code>.
// * Оба метода должны использовать бинарный поиск для первичного нахождения элемента. После нахождения вхождения
// * поиск должен продолжаться в соответствующем направлении (влево для первого вхождения и вправо для последнего)
// * с целью вернуть корректный индекс. Если элемент не найден, метод должен вернуть <code>-1</code>.
// * <strong>Замечания:</strong>
// *     Используйте только стандартные библиотеки Java.
// *     Можно предполагать, что массив уже отсортирован по возрастанию.
//     * Возвращает индекс первого вхождения указанного элемента (target) в отсортированном массиве.
//     * Этот метод должен:
//     *     Использовать бинарный поиск для нахождения любого вхождения элемента.
//     *     После нахождения элемента продолжить поиск влево для определения первого вхождения.
//     *     Возвращать <code>-1</code>, если элемент не найден в массиве.
//     * @param arr    отсортированный массив, в котором производится поиск
//     * @param target элемент, первое вхождение которого необходимо найти
//     * @return индекс первого вхождения target, если оно существует; в противном случае, -1
public class BinarySearchHomework {
    public int firstCount(int[] arr, int target) throws UnsupportedOperationException {
        //Инициализация границ:
        int left = 0;
        int right = arr.length - 1;
        int result = -1;

        //Бинарный поиск:
        while (left <= right) {
            int mid = left + (right - left) / 2;
            //Сравнение с target:
            if (arr[mid] == target) {
                result = mid;  // нашли target
                right = mid - 1; //продолжаем искать левее
            } else if (arr[mid] < target) {
                left = mid + 1; //target правее
            } else {
                right = mid - 1; //target левее
            }
        }
        return result;
    }

    /**
     * Возвращает индекс последнего вхождения указанного элемента (target) в отсортированном массиве.
     * Этот метод должен:
     * Использовать бинарный поиск для нахождения любого вхождения элемента.
     * После нахождения элемента продолжить поиск вправо для определения последнего вхождения.
     * Возвращать <code>-1</code>, если элемент не найден в массиве.
     *
     * @param arr    отсортированный массив, в котором производится поиск
     * @param target элемент, последнее вхождение которого необходимо найти
     * @return индекс последнего вхождения target, если оно существует; в противном случае, -1
     */
    public int lastCount(int[] arr, int target) {
        int left = 0;
        int right = arr.length - 1;
        int result = -1;

        while (left <= right) {
            int mid = left + (right - left) / 2;

            if (arr[mid] == target) {
                result = mid;
                left = mid + 1;//продолжаем поиск вправо
            } else if (arr[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }

        return result;
    }
}


