package Homework.lesson_38;

/**
 * Домашнее задание: Бинарный поиск первого и последнего вхождения
 *
 * <p>
 * Цель данного задания – реализовать два метода, которые находят первое и последнее вхождение
 * заданного элемента (target) в отсортированном массиве с использованием бинарного поиска.
 * </p>
 *
 * <p>
 * Вам необходимо реализовать следующие два метода:
 * <ul>
 *   <li>
 *     <code>int firstCount(int[] arr, int target)</code> – метод, который должен возвращать индекс первого вхождения
 *     элемента <code>target</code> в отсортированном массиве <code>arr</code>.
 *   </li>
 *   <li>
 *     <code>int lastCount(int[] arr, int target)</code> – метод, который должен возвращать индекс последнего вхождения
 *     элемента <code>target</code> в отсортированном массиве <code>arr</code>.
 *   </li>
 * </ul>
 * </p>
 *
 * <p>
 * Оба метода должны использовать бинарный поиск для первичного нахождения элемента. После нахождения вхождения
 * поиск должен продолжаться в соответствующем направлении (влево для первого вхождения и вправо для последнего)
 * с целью вернуть корректный индекс. Если элемент не найден, метод должен вернуть <code>-1</code>.
 * </p>
 *
 * <p>
 * <strong>Замечания:</strong>
 * <ul>
 *   <li>
 *     Используйте только стандартные библиотеки Java.
 *   </li>
 *   <li>
 *     Можно предполагать, что массив уже отсортирован по возрастанию.
 *   </li>
 * </ul>
 * </p>
 *
 * <p>
 * <strong>Инструкции:</strong> Реализуйте методы ниже в рамках выполнения домашнего задания.
 * </p>
 */
public class BinarySearchHomework {

    /**
     * Возвращает индекс первого вхождения указанного элемента (target) в отсортированном массиве.
     * <p>
     * Этот метод должен:
     * <ul>
     *   <li>
     *     Использовать бинарный поиск для нахождения любого вхождения элемента.
     *   </li>
     *   <li>
     *     После нахождения элемента продолжить поиск влево для определения первого вхождения.
     *   </li>
     *   <li>
     *     Возвращать <code>-1</code>, если элемент не найден в массиве.
     *   </li>
     * </ul>
     *
     * @param arr    отсортированный массив, в котором производится поиск
     * @param target элемент, первое вхождение которого необходимо найти
     * @return индекс первого вхождения target, если оно существует; в противном случае, -1
     */
    public int firstCount(int[] arr, int target) {
        if (arr == null || arr.length == 0) return -1; // Проверка на пустой массив
        int low = 0; // Левая граница диапазона поиска
        int high = arr.length - 1; // Правая граница диапазона поиска
        int result = -1; // Хранит индекс первого вхождения

        while (low <= high) { // Пока диапазон поиска не пуст
            int mid = low + (high - low) / 2; // Вычисление середины (без переполнения)
            if (arr[mid] == target) { // Элемент найден
                result = mid; // Сохраняем текущий индекс как кандидата
                high = mid - 1; // Сужаем поиск влево (ищем первое вхождение)
            } else if (arr[mid] < target) { // Искомый элемент правее
                low = mid + 1; // Сдвигаем левую границу вправо
            } else { // Искомый элемент левее
                high = mid - 1; // Сдвигаем правую границу влево
            }
        }
        return result; // Возвращаем индекс первого вхождения или -1
    }

    /**
     * Возвращает индекс последнего вхождения указанного элемента (target) в отсортированном массиве.
     * <p>
     * Этот метод должен:
     * <ul>
     *   <li>
     *     Использовать бинарный поиск для нахождения любого вхождения элемента.
     *   </li>
     *   <li>
     *     После нахождения элемента продолжить поиск вправо для определения последнего вхождения.
     *   </li>
     *   <li>
     *     Возвращать <code>-1</code>, если элемент не найден в массиве.
     *   </li>
     * </ul>
     *
     * @param arr    отсортированный массив, в котором производится поиск
     * @param target элемент, последнее вхождение которого необходимо найти
     * @return индекс последнего вхождения target, если оно существует; в противном случае, -1
     */
    public int lastCount(int[] arr, int target) {
        if (arr == null || arr.length == 0) return -1; // Проверка на пустой массив
        int low = 0; // Левая граница диапазона поиска
        int high = arr.length - 1; // Правая граница диапазона поиска
        int result = -1; // Хранит индекс последнего вхождения

        while (low <= high) { // Пока диапазон поиска не пуст
            int mid = low + (high - low) / 2; // Вычисление середины (без переполнения)
            if (arr[mid] == target) { // Элемент найден
                result = mid; // Сохраняем текущий индекс как кандидата
                low = mid + 1; // Сужаем поиск вправо (ищем последнее вхождение)
            } else if (arr[mid] < target) { // Искомый элемент правее
                low = mid + 1; // Сдвигаем левую границу вправо
            } else { // Искомый элемент левее
                high = mid - 1; // Сдвигаем правую границу влево
            }
        }
        return result; // Возвращаем индекс последнего вхождения или -1
    }
}
